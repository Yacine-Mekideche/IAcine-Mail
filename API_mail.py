{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "724c3871-7477-4a0f-b917-4b634d001fee",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "##########################################\n",
      "##                                      ##\n",
      "##        Bienvenue sur IAcine !        ##\n",
      "##                                      ##\n",
      "##        Votre IAssistant Gmail        ##\n",
      "##         qui gère vos messages.       ##\n",
      "##                                      ##\n",
      "##########################################\n",
      "##                                      ##\n",
      "##              ATTENTION :             ##\n",
      "##   Ce programme récupère et traite    ##\n",
      "##      le contenu de vos e-mails       ##\n",
      "##         non-lus via GPT-3.5.         ##\n",
      "##                                      ##\n",
      "##      Tapez 'oui' pour continuer      ##\n",
      "##                                      ##\n",
      "##########################################\n",
      "##       © 2024 - Yacine Mekideche.     ##\n",
      "##         Tous droits réservés.        ##\n",
      "##########################################\n"
     ]
    },
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      " oui\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Authentification...\n",
      "Please visit this URL to authorize this application: https://accounts.google.com/o/oauth2/auth?response_type=code&client_id=294025001032-pfulp1drn1bk37auvi3okmime39g07i7.apps.googleusercontent.com&redirect_uri=http%3A%2F%2Flocalhost%3A64048%2F&scope=openid+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.profile+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fgmail.readonly+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fgmail.send+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fgmail.modify&state=ZjK5sFst24ESBjVHRNWKL2cxl1WRp7&access_type=offline\n",
      "Authentification réussie !\n",
      "Lecture des messages non-lus en cours...\n",
      "1 mail non-lu.\n",
      "Génération de la réponse en cours...\n",
      "Création du brouillon en cours...\n",
      "Brouillon créé avec l'ID : r-6350813763537659864\n",
      "Message marqué comme lu.\n",
      "Message ID 1919de773c3c220b marqué comme lu.\n",
      "Fini !\n",
      "Brouillon créé pour 1 message.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n",
      "Lecture des messages non-lus en cours...\n",
      "Aucun message non-lu.\n",
      "Attente (10 secondes)...\n"
     ]
    },
    {
     "ename": "KeyboardInterrupt",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[14], line 339\u001b[0m\n\u001b[0;32m    330\u001b[0m         time\u001b[38;5;241m.\u001b[39msleep(\u001b[38;5;241m10\u001b[39m)\n\u001b[0;32m    338\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;18m__name__\u001b[39m \u001b[38;5;241m==\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124m__main__\u001b[39m\u001b[38;5;124m'\u001b[39m:\n\u001b[1;32m--> 339\u001b[0m     main()\n",
      "Cell \u001b[1;32mIn[14], line 330\u001b[0m, in \u001b[0;36mmain\u001b[1;34m()\u001b[0m\n\u001b[0;32m    328\u001b[0m reply_to_unread_messages(gmail_service, context, info)\n\u001b[0;32m    329\u001b[0m \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mAttente (10 secondes)...\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n\u001b[1;32m--> 330\u001b[0m time\u001b[38;5;241m.\u001b[39msleep(\u001b[38;5;241m10\u001b[39m)\n",
      "\u001b[1;31mKeyboardInterrupt\u001b[0m: "
     ]
    }
   ],
   "source": [
    "# Importation des bibliothèques nécessaires\n",
    "from google_auth_oauthlib.flow import InstalledAppFlow\n",
    "from google.auth.transport.requests import Request\n",
    "from googleapiclient.discovery import build\n",
    "from email.mime.text import MIMEText\n",
    "import pickle\n",
    "import base64\n",
    "import email\n",
    "import time\n",
    "import sys\n",
    "import os\n",
    "from openai import OpenAI\n",
    "import locale\n",
    "from datetime import datetime, timedelta, timezone\n",
    "\n",
    "\n",
    "\n",
    "# Configuration de la locale pour le français et le fuseau horaire de Paris\n",
    "locale.setlocale(locale.LC_TIME, 'fr_FR.UTF-8')\n",
    "paris_tz = timezone(timedelta(hours=2))\n",
    "\n",
    "\n",
    "\n",
    "# Fonction principale pour traiter les emails non-lus\n",
    "def reply_to_unread_messages(gmail_service, context, info):\n",
    "    print(\"Lecture des messages non-lus en cours...\")\n",
    "    messages = get_messages(gmail_service)  # Récupère les messages non-lus\n",
    "\n",
    "    num_messages = len(messages)  # Compte le nombre de messages non-lus\n",
    "    if num_messages == 1:\n",
    "        print(\"1 mail non-lu.\")\n",
    "    elif num_messages > 1:\n",
    "        print(f\"{num_messages} mails non-lus.\")\n",
    "    else:\n",
    "        print(\"Aucun message non-lu.\")\n",
    "        return\n",
    "\n",
    "    # Boucle à travers chaque message non-lu\n",
    "    for message in messages:\n",
    "        raw_email = get_message_body(message[\"raw\"])  # Récupère le corps du message\n",
    "\n",
    "        print(\"Génération de la réponse en cours...\")\n",
    "        reply = make_reply(raw_email, context)  # Génère une réponse via GPT-3.5\n",
    "\n",
    "        # Formatage de la date et heure actuelle en français\n",
    "        current_date = datetime.now(paris_tz).strftime(\"%a, %d %b %Y %H:%M:%S %z\")\n",
    "        sender_name = message[\"json\"][\"sender_name\"]\n",
    "        sender_email = message[\"json\"][\"sender_email\"]\n",
    "        subject = message[\"json\"][\"subject\"]\n",
    "        message_id = message[\"json\"][\"message_id\"]\n",
    "\n",
    "        # Construction du bloc de réponse avec l'email original en citation\n",
    "        reply_block = \"\\n\".join([\"> \" + line for line in raw_email.split(\"\\n\")])\n",
    "        raw_reply = reply + f\"\\n\\nLe {current_date}, {sender_name} <{sender_email}> a écrit:\\n\\n\" + reply_block\n",
    "\n",
    "        # Informations sur l'expéditeur et sujet de la réponse\n",
    "        my_info = info[\"name\"] + \" <\"+info[\"email\"]+\">\"\n",
    "        re_subject = \"Re: \" + subject.removeprefix(\"Re: \")\n",
    "\n",
    "        # Préparation des en-têtes de l'email\n",
    "        headers = {\n",
    "            \"In-Reply-To\": message_id,\n",
    "            \"References\": message_id,\n",
    "        }\n",
    "\n",
    "        # Création du message pour le brouillon\n",
    "        new_message = create_message(my_info, sender_email, re_subject, raw_reply, headers)\n",
    "\n",
    "        print(\"Création du brouillon en cours...\")\n",
    "        create_draft(gmail_service, new_message)  # Stocke le message en tant que brouillon\n",
    "\n",
    "        print(\"Message marqué comme lu.\")\n",
    "        mark_message_as_read(gmail_service, message[\"json\"][\"id\"])  # Marque le message comme lu\n",
    "\n",
    "        print(\"Fini !\")\n",
    "\n",
    "    # Affichage du nombre de brouillons créés\n",
    "    if num_messages == 1:\n",
    "        print(\"Brouillon créé pour 1 message.\")\n",
    "    else:\n",
    "        print(f\"Brouillons créés pour {num_messages} messages.\")\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# Liste des autorisations demandées pour accéder à Gmail et d'autres services Google\n",
    "SCOPES = [\n",
    "    'openid',\n",
    "    'https://www.googleapis.com/auth/userinfo.profile',\n",
    "    'https://www.googleapis.com/auth/userinfo.email',\n",
    "    'https://www.googleapis.com/auth/gmail.readonly',\n",
    "    'https://www.googleapis.com/auth/gmail.send',\n",
    "    'https://www.googleapis.com/auth/gmail.modify',\n",
    "]\n",
    "\n",
    "\n",
    "\n",
    "# Initialisation du client OpenAI avec la clé API\n",
    "client = OpenAI(api_key='clé_API')  # Remplacez par votre clé API\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# Fonction pour initialiser les services Google nécessaires (Gmail, People)\n",
    "def get_services():\n",
    "    creds = None\n",
    "    # Suppression du fichier de token précédent pour forcer une nouvelle authentification\n",
    "    if os.path.exists('token.pickle'):\n",
    "        os.remove('token.pickle')\n",
    "\n",
    "    # Chargement des identifiants d'accès s'ils existent\n",
    "    if os.path.exists('token.pickle'):\n",
    "        with open('token.pickle', 'rb') as token:\n",
    "            creds = pickle.load(token)\n",
    "\n",
    "    # Si les identifiants ne sont pas valides ou manquants, demander l'authentification\n",
    "    if not creds or not creds.valid:\n",
    "        if creds and creds.expired and creds.refresh_token:\n",
    "            creds.refresh(Request())\n",
    "        else:\n",
    "            flow = InstalledAppFlow.from_client_secrets_file(\n",
    "                'credentials.json', SCOPES)\n",
    "            creds = flow.run_local_server(port=0)\n",
    "        with open('token.pickle', 'wb') as token:\n",
    "            pickle.dump(creds, token)\n",
    "\n",
    "    # Retourne les services Gmail et People avec les credentials obtenus\n",
    "    return {\n",
    "        \"gmail\": build('gmail', 'v1', credentials=creds),\n",
    "        \"people\": build('people', 'v1', credentials=creds),\n",
    "    }\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# Fonction pour obtenir les informations de l'utilisateur connecté (nom, email)\n",
    "def get_user_info(service):\n",
    "    profile = service.people().get(resourceName='people/me', personFields='names,emailAddresses').execute()\n",
    "    name = profile['names'][0]['displayName']\n",
    "    email = profile['emailAddresses'][0]['value']\n",
    "    return {\"name\": name, \"email\": email}\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# Fonction pour créer un message email\n",
    "def create_message(sender, to, subject, message_text, headers=None):\n",
    "    message = MIMEText(message_text)\n",
    "    message['to'] = to\n",
    "    message['from'] = sender\n",
    "    message['subject'] = subject\n",
    "    if headers:\n",
    "        for name, value in headers.items():\n",
    "            message[name] = value\n",
    "    raw_message = base64.urlsafe_b64encode(message.as_bytes()).decode()\n",
    "    return {'raw': raw_message}\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# Fonction pour envoyer un message email via l'API Gmail\n",
    "def send_message(service, message):\n",
    "    message = service.users().messages().send(userId='me', body=message).execute()\n",
    "    print(f\"Message envoyé: {message['id']}\")\n",
    "    return message\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# Fonction pour récupérer le corps d'un message email\n",
    "def get_message_body(message):\n",
    "    msg_raw = base64.urlsafe_b64decode(message['raw'].encode('ASCII'))\n",
    "    msg_str = email.message_from_bytes(msg_raw)\n",
    "\n",
    "    # Si le message est multipart, on prend la partie text/plain\n",
    "    if msg_str.is_multipart():\n",
    "        for part in msg_str.walk():\n",
    "            if part.get_content_type() == 'text/plain':\n",
    "                body = part.get_payload(decode=True).decode()\n",
    "                return body\n",
    "    else:\n",
    "        body = msg_str.get_payload(decode=True).decode()\n",
    "        return body\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# Fonction pour marquer un message comme lu\n",
    "def mark_message_as_read(service, msg_id):\n",
    "    service.users().messages().modify(\n",
    "        userId=\"me\",\n",
    "        id=msg_id,\n",
    "        body={'removeLabelIds': ['UNREAD']}\n",
    "    ).execute()\n",
    "    print(f\"Message ID {msg_id} marqué comme lu.\")\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# Fonction pour récupérer les messages non-lus\n",
    "def get_messages(service):\n",
    "    results = service.users().messages().list(userId='me', labelIds=['UNREAD']).execute()\n",
    "    messages = results.get('messages', [])\n",
    "\n",
    "    message_list = []\n",
    "\n",
    "    for message in messages:\n",
    "        msg_raw = service.users().messages().get(userId='me', id=message['id'], format=\"raw\").execute()\n",
    "        msg_json = service.users().messages().get(userId='me', id=message['id']).execute()\n",
    "\n",
    "        headers = msg_json[\"payload\"][\"headers\"]\n",
    "        for header in headers:\n",
    "            if header[\"name\"] == \"From\":\n",
    "                sender = header[\"value\"]\n",
    "                if \"<\" in sender and \">\" in sender:\n",
    "                    sender_name = sender.split(\"<\")[0].strip()\n",
    "                    sender_email = sender.split(\"<\")[1].strip().removesuffix(\">\")\n",
    "                else:\n",
    "                    sender_name = sender\n",
    "                    sender_email = sender\n",
    "                msg_json[\"sender_name\"] = sender_name\n",
    "                msg_json[\"sender_email\"] = sender_email\n",
    "            if header[\"name\"] == \"Subject\":\n",
    "                msg_json[\"subject\"] = header[\"value\"]\n",
    "            if header[\"name\"] == \"Message-ID\":\n",
    "                msg_json[\"message_id\"] = header[\"value\"]\n",
    "\n",
    "        message_list.append({\n",
    "            \"raw\": msg_raw,\n",
    "            \"json\": msg_json,\n",
    "        })\n",
    "\n",
    "    return message_list\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# Fonction pour générer une réponse à l'aide du modèle GPT-3.5\n",
    "def make_reply(raw_email, context):\n",
    "    prompt = f\"Répondez de manière professionnelle et appropriée à cet email:\\n\\n{raw_email}\\n\\nContexte supplémentaire: {context}\"\n",
    "\n",
    "    response = client.chat.completions.create(\n",
    "        model=\"gpt-3.5-turbo\",\n",
    "        messages=[\n",
    "            {\"role\": \"system\", \"content\": \"Tu es un assistant intelligent qui répond aux emails reçus.\"},\n",
    "            {\"role\": \"user\", \"content\": prompt}\n",
    "        ],\n",
    "        max_tokens=1500,\n",
    "        temperature=0.7\n",
    "    )\n",
    "\n",
    "    return response.choices[0].message.content.strip()\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# Fonction pour créer un brouillon d'email\n",
    "def create_draft(service, message):\n",
    "    draft = service.users().drafts().create(userId='me', body={'message': message}).execute()\n",
    "    print(f\"Brouillon créé avec l'ID : {draft['id']}\")\n",
    "    return draft\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# Fonction principale pour lire les emails non-lus et générer des brouillons de réponses\n",
    "def reply_to_unread_messages(gmail_service, context, info):\n",
    "    print(\"Lecture des messages non-lus en cours...\")\n",
    "    messages = get_messages(gmail_service)  # Récupère les messages non-lus\n",
    "\n",
    "    num_messages = len(messages)  # Compte le nombre de messages non-lus\n",
    "    if num_messages == 1:\n",
    "        print(\"1 mail non-lu.\")  # Affiche qu'il y a 1 email non-lu\n",
    "    elif num_messages > 1:\n",
    "        print(f\"{num_messages} mails non-lus.\")  # Affiche le nombre d'emails non-lus\n",
    "    else:\n",
    "        print(\"Aucun message non-lu.\")  # Si aucun message n'est non-lu, quitte la fonction\n",
    "        return\n",
    "\n",
    "    # Boucle à travers chaque message non-lu pour générer une réponse et la sauvegarder en brouillon\n",
    "    for message in messages:\n",
    "        raw_email = get_message_body(message[\"raw\"])  # Récupère le corps du message\n",
    "\n",
    "        print(\"Génération de la réponse en cours...\")\n",
    "        reply = make_reply(raw_email, context)  # Génère une réponse via GPT-3.5\n",
    "\n",
    "        # Formatage de la date et heure actuelle en français\n",
    "        current_date = datetime.now(paris_tz).strftime(\"%a, %d %b %Y %H:%M:%S %z\")\n",
    "        sender_name = message[\"json\"][\"sender_name\"]\n",
    "        sender_email = message[\"json\"][\"sender_email\"]\n",
    "        subject = message[\"json\"][\"subject\"]\n",
    "        message_id = message[\"json\"][\"message_id\"]\n",
    "\n",
    "        # Construction du bloc de réponse avec l'email original en citation\n",
    "        reply_block = \"\\n\".join([\"> \" + line for line in raw_email.split(\"\\n\")])\n",
    "        raw_reply = reply + f\"\\n\\nLe {current_date}, {sender_name} <{sender_email}> a écrit:\\n\\n\" + reply_block\n",
    "\n",
    "        # Informations sur l'expéditeur et sujet de la réponse\n",
    "        my_info = info[\"name\"] + \" <\"+info[\"email\"]+\">\"\n",
    "        re_subject = \"Re: \" + subject.removeprefix(\"Re: \")\n",
    "\n",
    "        # Préparation des en-têtes de l'email\n",
    "        headers = {\n",
    "            \"In-Reply-To\": message_id,\n",
    "            \"References\": message_id,\n",
    "        }\n",
    "\n",
    "        # Création du message pour le brouillon\n",
    "        new_message = create_message(my_info, sender_email, re_subject, raw_reply, headers)\n",
    "\n",
    "        print(\"Création du brouillon en cours...\")\n",
    "        create_draft(gmail_service, new_message)  # Stocke le message en tant que brouillon\n",
    "\n",
    "        print(\"Message marqué comme lu.\")\n",
    "        mark_message_as_read(gmail_service, message[\"json\"][\"id\"])  # Marque le message comme lu\n",
    "\n",
    "        print(\"Fini !\")\n",
    "\n",
    "    # Affichage du nombre de brouillons créés\n",
    "    if num_messages == 1:\n",
    "        print(\"Brouillon créé pour 1 message.\")\n",
    "    else:\n",
    "        print(f\"Brouillons créés pour {num_messages} messages.\")\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# Fonction principale du programme\n",
    "def main():\n",
    "    if len(sys.argv) == 2:\n",
    "        with open(sys.argv[1], \"r\") as f:\n",
    "            context = f.read()  # Lit le contexte depuis un fichier si fourni en argument\n",
    "    else:\n",
    "        context = \"\"\n",
    "\n",
    "    # Affiche le message de bienvenue et les instructions pour continuer\n",
    "    print( \"##########################################\" )\n",
    "    print( \"##                                      ##\" )\n",
    "    print( \"##        Bienvenue sur IAcine !        ##\" )\n",
    "    print( \"##                                      ##\" )\n",
    "    print( \"##        Votre IAssistant Gmail        ##\" )\n",
    "    print( \"##         qui gère vos messages.       ##\" )\n",
    "    print( \"##                                      ##\" )\n",
    "    print( \"##########################################\" )\n",
    "    print( \"##                                      ##\" )\n",
    "    print( \"##              ATTENTION :             ##\" )\n",
    "    print( \"##   Ce programme récupère et traite    ##\" )\n",
    "    print( \"##      le contenu de vos e-mails       ##\" )\n",
    "    print( \"##         non-lus via GPT-3.5.         ##\" )\n",
    "    print( \"##                                      ##\" )\n",
    "    print( \"##      Tapez 'oui' pour continuer      ##\" )\n",
    "    print( \"##                                      ##\" )\n",
    "    print( \"##########################################\" )\n",
    "    print( \"##       © 2024 - Yacine Mekideche.     ##\" )\n",
    "    print( \"##         Tous droits réservés.        ##\" )\n",
    "    print( \"##########################################\" )\n",
    "\n",
    "    # Si l'utilisateur ne tape pas \"oui\", le programme se ferme\n",
    "    if input() != \"oui\":\n",
    "        print(\"Fermeture du programme.\")\n",
    "        sys.exit()\n",
    "\n",
    "    print(\"Authentification...\")\n",
    "    services = get_services()  # Authentifie l'utilisateur et obtient les services nécessaires\n",
    "\n",
    "    gmail_service = services[\"gmail\"]\n",
    "    people_service = services[\"people\"]\n",
    "\n",
    "    print(\"Authentification réussie !\")\n",
    "    info = get_user_info(people_service)  # Récupère les informations de l'utilisateur\n",
    "\n",
    "    # Boucle infinie pour vérifier les emails toutes les 10 secondes\n",
    "    while True:\n",
    "        reply_to_unread_messages(gmail_service, context, info)  # Répond aux emails non-lus\n",
    "        print(\"Attente (10 secondes)...\")\n",
    "        time.sleep(10)\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# Point d'entrée du programme\n",
    "if __name__ == '__main__':\n",
    "    main()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "23c9f6df-86e5-4b49-ae8d-3f2c792922a5",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a1333688-c8b6-44e1-ab50-b683f5f6fbfa",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
